/*
 * Copyright (c) 2015 Big boss
 * All rights reserved.
 */
package com.synflow.uart;

import com.synflow.uart.UartImp.*;

network UartRx {
	in bool rx;
	out sync char dout;

	prescaler = new task {
		/**
	 	 * This task implements a tick generator for the UART 
		 * BAUD RATE are usually from 9600 to 115200
		 * 
		 * See UartTx for more details
		 * 
		 * @author Nicolas Siret
		 */
		out sync bool tick;

		u17 tickGen;
		void loop() {
			tickGen = (u16) tickGen + BAUD_GEN_OVER;
			if (tickGen[16]) {
				tick.write(tickGen[16]);
			}
		}
	};

	sampler = new task {
		out sync bool sample;
		void loop() {
			if (prescaler.tick.read()) {
				sample.write(rx.read());
			}
		}
	};

	detectStart = new task {
		/**
	     * Filter the rxd to suppress spikes using a 2 bit counter
		 * 
		 * 
		 * @author Nicolas Siret
		 */
		sync {
			in bool sample; out bool startRx;
		}

		void loop() {
			u5 counter = 0;
			while (counter != 3) {
				if (sample.read && counter != 0) {
					counter--;
				} else if (!sample.read) {
					counter++;
				}
			}

			while (counter != OVERSAMPLING) {
				sample.read();
				counter++;
			}
			startRx.write(true);
		}

	};
	detectStart.reads(sampler.sample);
	
	filter = new task {
		in bool start;
		out sync bool filtered;
		u5 bit_value;
		void loop() {
			while (!start.read()) {}

			for (u5 counter = 0; counter != OVERSAMPLING; counter++) {
				if (sampler.sample.read()) {
					bit_value++;
				} else if (bit_value != 0) {
					bit_value--;
				}
			}
			
			filtered.write(bit_value >= OVERSAMPLING / 2);
		}
	};

	rxTask = new task {
		u8 data;

		void loop() {
			detectStart: detectStart.startRx.read(); // Wait for the start bit
			filter.start.write(true);

			saveData: for (u4 i = 0; i != 8; i++) { // read data (LSB)
				data >>= 1;
				data[7] = filter.filtered.read();
			}

			if (filter.filtered.read()) {
				dout.write(data);
				print("UART Rx data: ", data);
			}
			filter.start.write(false);
		}
	};
}
